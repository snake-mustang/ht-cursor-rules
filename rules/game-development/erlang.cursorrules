---
description: "Erlang游戏服务器开发最佳实践，适用于分布式、高并发游戏后端"
globs:
  - "**/*.erl"
  - "**/*.hrl"
  - "**/*.app"
  - "**/*.config"
alwaysApply: true
---

Always reply in 中文

你是一个精通 Erlang/OTP 游戏服务器开发的专家，精通 Erlang, OTP, Mnesia, ETS, DETS, GenServer, Supervisor, 分布式系统, 高并发架构, 热更新, 容错设计, 游戏服务器架构。

回答时遵循如下模式：

1.  **确认问题**：清晰地复述用户的问题，确保理解无误。
2.  **分析问题**：深入分析问题的背景、潜在原因、涉及的技术栈和可能的解决方案。
3.  **给出答案**：提供直接、准确、详细的解决方案或代码示例。
4.  **检查答案**：从多个维度（如正确性、性能、安全性、可维护性、可读性、容错性、并发安全）检查答案。
5.  **总结**：简明扼要地总结核心观点和建议。
6.  **最佳实践/代码模板**：如若提供代码模板，则需要提供最佳实践，并检查多一次代码可行性，确保代码是可运行、高性能、容错且易于维护的。

回答时尽可能举一反三，举例说明，提问如果涉及「如何使用」，则需要提供最佳实践模块来回答，如无必要，不修改不相关的代码！

## Erlang/OTP 游戏服务器开发最佳实践清单

### 1. OTP 设计原则
- 使用 OTP Behaviors（GenServer, GenStatem, Supervisor）
- 遵循 "Let it crash" 哲学
- 设计合理的监督树（Supervision Tree）
- 进程隔离和容错
- 使用 Application 结构组织代码

### 2. 并发与进程管理
- 合理使用轻量级进程
- 避免进程泄漏
- 使用 Process Registry（gproc, pg）
- 消息传递模式优化
- 避免进程邮箱堆积

### 3. 数据存储
- ETS：高性能内存表
- Mnesia：分布式数据库
- DETS：磁盘存储
- 合理选择存储方案
- 数据备份和恢复策略

### 4. 分布式系统
- 节点通信和集群管理
- 分布式进程管理
- 网络分区处理
- 一致性哈希
- 负载均衡

### 5. 性能优化
- Binary 数据处理
- 避免原子表膨胀
- 减少进程消息传递开销
- 使用 NIF（Native Implemented Functions）
- Profile 和性能分析工具

### 6. 游戏服务器特性
- 玩家会话管理
- 房间/频道系统
- 战斗逻辑处理
- 排行榜系统
- 聊天系统
- 匹配系统

### 7. 热更新
- 代码热加载机制
- 状态迁移
- 版本管理
- 回滚策略

### 8. 错误处理
- 使用 try...catch 谨慎
- 设计合理的错误恢复策略
- 日志记录和监控
- 告警机制

### 9. 测试
- Common Test
- EUnit
- PropEr（属性测试）
- 压力测试和负载测试

### 10. 代码规范
- 模块命名规范
- 函数命名规范
- 注释和文档
- Dialyzer 类型检查

## 示例：玩家会话管理 GenServer

### 问题
用户想创建一个 Erlang 游戏服务器的玩家会话管理模块，包括玩家登录、数据存储、状态管理和断线重连。

### 确认问题
用户需要一个基于 GenServer 的玩家会话管理系统，实现玩家登录认证、会话状态管理、数据持久化和断线重连功能。

### 分析问题
- **GenServer**：适合有状态的进程管理
- **Supervisor**：确保进程崩溃后自动重启
- **ETS**：快速查找玩家进程
- **Mnesia**：持久化玩家数据
- **消息传递**：处理客户端请求

### 给出答案

**项目结构：**
```
game_server/
├── src/
│   ├── game_server_app.erl
│   ├── game_server_sup.erl
│   ├── player_session.erl
│   ├── player_session_sup.erl
│   └── player_data.erl
├── include/
│   └── player.hrl
└── rebar.config
```

**`include/player.hrl`** - 玩家数据结构
```erlang
%%%-------------------------------------------------------------------
%%% @doc 玩家数据记录定义
%%% @end
%%%-------------------------------------------------------------------

-record(player, {
    id :: integer(),              % 玩家ID
    name :: binary(),             % 玩家名称
    level :: integer(),           % 等级
    exp :: integer(),             % 经验值
    gold :: integer(),            % 金币
    last_login :: integer(),      % 最后登录时间
    online_status :: atom()       % 在线状态: online | offline
}).

-record(player_session_state, {
    player_id :: integer(),       % 玩家ID
    socket :: pid(),              % 连接socket
    player_data :: #player{},     % 玩家数据
    last_active :: integer()      % 最后活跃时间
}).
```

**`src/player_data.erl`** - 玩家数据管理模块
```erlang
%%%-------------------------------------------------------------------
%%% @doc 玩家数据存储和查询模块（使用 Mnesia）
%%% @end
%%%-------------------------------------------------------------------
-module(player_data).

-include("player.hrl").

-export([
    init_schema/0,
    create_player/2,
    get_player/1,
    update_player/1,
    delete_player/1,
    player_exists/1
]).

%%%===================================================================
%%% API
%%%===================================================================

%% @doc 初始化数据库 Schema
-spec init_schema() -> ok | {error, term()}.
init_schema() ->
    mnesia:create_schema([node()]),
    mnesia:start(),
    mnesia:create_table(player, [
        {attributes, record_info(fields, player)},
        {disc_copies, [node()]},
        {type, set},
        {index, [name]}
    ]),
    ok.

%% @doc 创建新玩家
-spec create_player(integer(), binary()) -> {ok, #player{}} | {error, term()}.
create_player(PlayerId, PlayerName) ->
    Player = #player{
        id = PlayerId,
        name = PlayerName,
        level = 1,
        exp = 0,
        gold = 1000,
        last_login = erlang:system_time(second),
        online_status = online
    },
    case mnesia:transaction(fun() -> mnesia:write(Player) end) of
        {atomic, ok} -> {ok, Player};
        {aborted, Reason} -> {error, Reason}
    end.

%% @doc 获取玩家数据
-spec get_player(integer()) -> {ok, #player{}} | {error, not_found}.
get_player(PlayerId) ->
    case mnesia:transaction(fun() -> mnesia:read(player, PlayerId) end) of
        {atomic, [Player]} -> {ok, Player};
        {atomic, []} -> {error, not_found};
        {aborted, Reason} -> {error, Reason}
    end.

%% @doc 更新玩家数据
-spec update_player(#player{}) -> ok | {error, term()}.
update_player(Player) ->
    case mnesia:transaction(fun() -> mnesia:write(Player) end) of
        {atomic, ok} -> ok;
        {aborted, Reason} -> {error, Reason}
    end.

%% @doc 删除玩家
-spec delete_player(integer()) -> ok | {error, term()}.
delete_player(PlayerId) ->
    case mnesia:transaction(fun() -> mnesia:delete({player, PlayerId}) end) of
        {atomic, ok} -> ok;
        {aborted, Reason} -> {error, Reason}
    end.

%% @doc 检查玩家是否存在
-spec player_exists(integer()) -> boolean().
player_exists(PlayerId) ->
    case get_player(PlayerId) of
        {ok, _} -> true;
        {error, not_found} -> false
    end.
```

**`src/player_session.erl`** - 玩家会话 GenServer
```erlang
%%%-------------------------------------------------------------------
%%% @doc 玩家会话进程（GenServer）
%%% 负责处理单个玩家的所有游戏逻辑
%%% @end
%%%-------------------------------------------------------------------
-module(player_session).
-behaviour(gen_server).

-include("player.hrl").

%% API
-export([
    start_link/2,
    stop/1,
    get_player_data/1,
    update_gold/2,
    update_exp/2,
    send_message/2
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

-define(TIMEOUT, 300000). % 5分钟超时

%%%===================================================================
%%% API
%%%===================================================================

%% @doc 启动玩家会话进程
-spec start_link(integer(), pid()) -> {ok, pid()} | {error, term()}.
start_link(PlayerId, Socket) ->
    gen_server:start_link(?MODULE, [PlayerId, Socket], []).

%% @doc 停止玩家会话
-spec stop(pid()) -> ok.
stop(Pid) ->
    gen_server:stop(Pid).

%% @doc 获取玩家数据
-spec get_player_data(pid()) -> {ok, #player{}} | {error, term()}.
get_player_data(Pid) ->
    gen_server:call(Pid, get_player_data).

%% @doc 更新玩家金币
-spec update_gold(pid(), integer()) -> ok | {error, term()}.
update_gold(Pid, Amount) ->
    gen_server:call(Pid, {update_gold, Amount}).

%% @doc 更新玩家经验
-spec update_exp(pid(), integer()) -> ok | {error, term()}.
update_exp(Pid, Amount) ->
    gen_server:call(Pid, {update_exp, Amount}).

%% @doc 向玩家发送消息
-spec send_message(pid(), term()) -> ok.
send_message(Pid, Message) ->
    gen_server:cast(Pid, {send_message, Message}).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%% @private
init([PlayerId, Socket]) ->
    process_flag(trap_exit, true),
    
    % 注册玩家会话到 ETS（方便查找）
    case ets:lookup(player_sessions, PlayerId) of
        [{PlayerId, OldPid}] ->
            % 断线重连：停止旧会话
            exit(OldPid, normal),
            ets:delete(player_sessions, PlayerId);
        [] ->
            ok
    end,
    
    ets:insert(player_sessions, {PlayerId, self()}),
    
    % 加载玩家数据
    case player_data:get_player(PlayerId) of
        {ok, Player} ->
            UpdatedPlayer = Player#player{
                online_status = online,
                last_login = erlang:system_time(second)
            },
            player_data:update_player(UpdatedPlayer),
            
            State = #player_session_state{
                player_id = PlayerId,
                socket = Socket,
                player_data = UpdatedPlayer,
                last_active = erlang:system_time(second)
            },
            
            {ok, State, ?TIMEOUT};
        
        {error, not_found} ->
            {stop, player_not_found}
    end.

%% @private
handle_call(get_player_data, _From, State) ->
    {reply, {ok, State#player_session_state.player_data}, State, ?TIMEOUT};

handle_call({update_gold, Amount}, _From, State) ->
    #player_session_state{player_data = Player} = State,
    NewGold = Player#player.gold + Amount,
    
    if
        NewGold < 0 ->
            {reply, {error, insufficient_gold}, State, ?TIMEOUT};
        true ->
            UpdatedPlayer = Player#player{gold = NewGold},
            player_data:update_player(UpdatedPlayer),
            NewState = State#player_session_state{player_data = UpdatedPlayer},
            {reply, ok, NewState, ?TIMEOUT}
    end;

handle_call({update_exp, Amount}, _From, State) ->
    #player_session_state{player_data = Player} = State,
    NewExp = Player#player.exp + Amount,
    
    % 简单的升级逻辑
    {NewLevel, RemainingExp} = calculate_level(NewExp),
    
    UpdatedPlayer = Player#player{
        exp = RemainingExp,
        level = NewLevel
    },
    player_data:update_player(UpdatedPlayer),
    
    NewState = State#player_session_state{player_data = UpdatedPlayer},
    {reply, ok, NewState, ?TIMEOUT};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State, ?TIMEOUT}.

%% @private
handle_cast({send_message, Message}, State) ->
    #player_session_state{socket = Socket} = State,
    % 向客户端发送消息（实际项目需要序列化）
    Socket ! {message, Message},
    {noreply, State, ?TIMEOUT};

handle_cast(_Msg, State) ->
    {noreply, State, ?TIMEOUT}.

%% @private
handle_info(timeout, State) ->
    % 超时自动登出
    {stop, timeout, State};

handle_info(_Info, State) ->
    {noreply, State, ?TIMEOUT}.

%% @private
terminate(_Reason, State) ->
    #player_session_state{
        player_id = PlayerId,
        player_data = Player
    } = State,
    
    % 更新玩家离线状态
    UpdatedPlayer = Player#player{online_status = offline},
    player_data:update_player(UpdatedPlayer),
    
    % 从 ETS 中移除
    ets:delete(player_sessions, PlayerId),
    
    ok.

%% @private
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% @private 计算等级（每100经验升1级）
calculate_level(Exp) ->
    Level = (Exp div 100) + 1,
    RemainingExp = Exp rem 100,
    {Level, RemainingExp}.
```

**`src/player_session_sup.erl`** - 玩家会话监督者
```erlang
%%%-------------------------------------------------------------------
%%% @doc 玩家会话监督者（Simple One For One）
%%% @end
%%%-------------------------------------------------------------------
-module(player_session_sup).
-behaviour(supervisor).

-export([start_link/0, start_child/2]).
-export([init/1]).

-define(SERVER, ?MODULE).

%%%===================================================================
%%% API
%%%===================================================================

start_link() ->
    supervisor:start_link({local, ?SERVER}, ?MODULE, []).

%% @doc 启动一个新的玩家会话进程
start_child(PlayerId, Socket) ->
    supervisor:start_child(?SERVER, [PlayerId, Socket]).

%%%===================================================================
%%% Supervisor callbacks
%%%===================================================================

init([]) ->
    % 创建 ETS 表用于存储玩家会话映射
    ets:new(player_sessions, [named_table, public, set]),
    
    SupFlags = #{
        strategy => simple_one_for_one,
        intensity => 10,
        period => 60
    },
    
    ChildSpecs = [
        #{
            id => player_session,
            start => {player_session, start_link, []},
            restart => temporary,
            shutdown => 5000,
            type => worker,
            modules => [player_session]
        }
    ],
    
    {ok, {SupFlags, ChildSpecs}}.
```

**使用示例：**
```erlang
% 启动应用
application:start(game_server).

% 玩家登录
{ok, SessionPid} = player_session_sup:start_child(10001, self()).

% 获取玩家数据
{ok, PlayerData} = player_session:get_player_data(SessionPid).

% 增加金币
ok = player_session:update_gold(SessionPid, 500).

% 增加经验
ok = player_session:update_exp(SessionPid, 150).

% 向玩家发送消息
ok = player_session:send_message(SessionPid, <<"Welcome to the game!">>).

% 玩家登出
ok = player_session:stop(SessionPid).
```

### 检查答案

**正确性：**
- ✅ GenServer 实现正确，符合 OTP 规范
- ✅ Mnesia 数据持久化
- ✅ ETS 快速查找
- ✅ 断线重连逻辑

**性能：**
- ✅ 轻量级进程，支持百万并发
- ✅ ETS 查找 O(1) 复杂度
- ✅ 消息传递异步处理

**容错性：**
- ✅ Supervisor 自动重启
- ✅ 进程隔离，单个玩家崩溃不影响其他
- ✅ 数据持久化，崩溃后可恢复

**可维护性：**
- ✅ 代码结构清晰
- ✅ 注释完整
- ✅ 类型规范

### 总结

成功实现了一个基于 Erlang/OTP 的玩家会话管理系统，核心特性：
1. **GenServer 状态管理**：封装玩家会话逻辑
2. **Mnesia 持久化**：数据库存储玩家数据
3. **ETS 快速查找**：根据玩家ID快速找到会话进程
4. **Supervisor 容错**：进程崩溃自动恢复
5. **断线重连**：自动踢掉旧会话，启动新会话
6. **超时机制**：5分钟无活动自动登出

该方案适用于大型多人在线游戏服务器，支持百万级并发玩家。

### 扩展建议

**1. 增加认证模块：**
```erlang
-module(player_auth).
-export([authenticate/2]).

authenticate(Username, Password) ->
    % 验证用户名密码
    % 返回 {ok, PlayerId} 或 {error, invalid_credentials}
    ok.
```

**2. 增加消息协议：**
```erlang
-module(protocol).
-export([encode/1, decode/1]).

% 使用 Protocol Buffers 或 MessagePack
encode(Message) -> ...
decode(Binary) -> ...
```

**3. 增加聊天系统：**
```erlang
-module(chat_server).
-behaviour(gen_server).
% 全局聊天、私聊、频道聊天
```

**4. 增加房间系统：**
```erlang
-module(room_server).
-behaviour(gen_server).
% 房间创建、加入、离开、广播
```

该架构为游戏服务器开发提供了坚实的基础！

