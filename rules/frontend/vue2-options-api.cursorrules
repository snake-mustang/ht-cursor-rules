---
description: "Vue 2 Options API 开发最佳实践和规范"
globs:
  - "src/**/*.vue"
  - "src/**/*.js"
alwaysApply: false
---

# Vue 2 Options API 开发规则

你是 Vue 2 Options API 开发专家，精通 Vue 2.x 生态系统、Vuex、Vue Router，编写高质量、符合 Vue 2 规范的应用程序。

## 核心原则

### 1. 组件命名规范
- **组件文件名**：使用 PascalCase（如 `UserProfile.vue`, `TodoList.vue`）
- **组件名称**：在组件内使用 PascalCase
- **Props**：使用 camelCase（在 JS 中）和 kebab-case（在模板中）
- **事件名称**：使用 kebab-case（如 `@update-user`）

### 2. Options API 顺序
推荐的选项顺序：
1. `name`
2. `components`
3. `props`
4. `data`
5. `computed`
6. `watch`
7. `created`, `mounted` 等生命周期钩子
8. `methods`

### 3. 响应式数据管理
- 使用 `data` 函数返回响应式数据
- 避免直接修改 props
- 使用 `this.$set` 添加响应式属性

## 组件基础结构

```vue
<template>
  <div class="user-profile">
    <h2>{{ displayName }}</h2>
    <p>{{ user.email }}</p>
    <button @click="handleUpdate">更新</button>
  </div>
</template>

<script>
export default {
  name: 'UserProfile',
  
  props: {
    userId: {
      type: [String, Number],
      required: true
    },
    userName: {
      type: String,
      default: ''
    }
  },
  
  data() {
    return {
      user: null,
      isLoading: false,
      error: null
    }
  },
  
  computed: {
    displayName() {
      return this.user ? this.user.name : this.userName
    },
    
    hasError() {
      return !!this.error
    }
  },
  
  watch: {
    userId: {
      immediate: true,
      handler(newId) {
        this.fetchUser(newId)
      }
    }
  },
  
  created() {
    console.log('Component created')
  },
  
  mounted() {
    console.log('Component mounted')
  },
  
  methods: {
    async fetchUser(id) {
      this.isLoading = true
      try {
        const response = await this.$http.get(`/api/users/${id}`)
        this.user = response.data
      } catch (error) {
        this.error = error.message
      } finally {
        this.isLoading = false
      }
    },
    
    handleUpdate() {
      this.$emit('update-user', this.user)
    }
  }
}
</script>

<style scoped>
.user-profile {
  padding: 20px;
}
</style>
```

## Props 验证

```javascript
export default {
  props: {
    // 基础类型检查
    title: String,
    likes: Number,
    isPublished: Boolean,
    commentIds: Array,
    author: Object,
    callback: Function,
    contactsPromise: Promise,
    
    // 多个可能的类型
    propA: [String, Number],
    
    // 必填的字符串
    propB: {
      type: String,
      required: true
    },
    
    // 带有默认值的数字
    propC: {
      type: Number,
      default: 100
    },
    
    // 带有默认值的对象
    propD: {
      type: Object,
      default: () => ({ message: 'hello' })
    },
    
    // 带有默认值的数组
    propE: {
      type: Array,
      default: () => []
    },
    
    // 自定义验证函数
    propF: {
      validator: (value) => {
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
}
```

## 计算属性

```javascript
export default {
  data() {
    return {
      firstName: 'John',
      lastName: 'Doe'
    }
  },
  
  computed: {
    // 只读计算属性
    fullName() {
      return `${this.firstName} ${this.lastName}`
    },
    
    // 带 getter 和 setter
    fullNameWithSetter: {
      get() {
        return `${this.firstName} ${this.lastName}`
      },
      set(newValue) {
        const names = newValue.split(' ')
        this.firstName = names[0]
        this.lastName = names[names.length - 1]
      }
    }
  }
}
```

## 侦听器

```javascript
export default {
  data() {
    return {
      question: '',
      answer: 'Questions usually contain a question mark. ;-)'
    }
  },
  
  watch: {
    // 简单侦听
    question(newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    },
    
    // 深度侦听
    user: {
      deep: true,
      handler(newUser) {
        console.log('User changed:', newUser)
      }
    },
    
    // 立即执行
    userId: {
      immediate: true,
      handler(newId) {
        this.fetchUser(newId)
      }
    }
  }
}
```

## 生命周期钩子

```javascript
export default {
  // 创建前
  beforeCreate() {
    console.log('beforeCreate')
  },
  
  // 创建完成
  created() {
    console.log('created')
    // 可以访问 data, computed, methods
    // 不能访问 DOM
  },
  
  // 挂载前
  beforeMount() {
    console.log('beforeMount')
  },
  
  // 挂载完成
  mounted() {
    console.log('mounted')
    // 可以访问 DOM
    this.$refs.myElement.focus()
  },
  
  // 更新前
  beforeUpdate() {
    console.log('beforeUpdate')
  },
  
  // 更新完成
  updated() {
    console.log('updated')
    // DOM 已更新
  },
  
  // 销毁前
  beforeDestroy() {
    console.log('beforeDestroy')
    // 清理定时器、事件监听等
    clearInterval(this.timer)
    window.removeEventListener('resize', this.handleResize)
  },
  
  // 销毁完成
  destroyed() {
    console.log('destroyed')
  }
}
```

## 事件处理

```vue
<template>
  <div>
    <!-- 方法处理器 -->
    <button @click="handleClick">点击</button>
    
    <!-- 内联处理器 -->
    <button @click="count++">{{ count }}</button>
    
    <!-- 访问原始 DOM 事件 -->
    <button @click="handleClick($event)">点击</button>
    
    <!-- 事件修饰符 -->
    <form @submit.prevent="onSubmit">
      <button type="submit">提交</button>
    </form>
    
    <!-- 按键修饰符 -->
    <input @keyup.enter="submit" />
    
    <!-- 鼠标按钮修饰符 -->
    <button @click.right="handleRightClick">右键</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  
  methods: {
    handleClick(event) {
      console.log(event.target)
    },
    
    onSubmit() {
      console.log('Form submitted')
    },
    
    submit() {
      console.log('Enter pressed')
    },
    
    handleRightClick() {
      console.log('Right click')
    }
  }
}
</script>
```

## 表单输入绑定

```vue
<template>
  <div>
    <!-- 文本 -->
    <input v-model="message" placeholder="编辑我" />
    <p>Message: {{ message }}</p>
    
    <!-- 多行文本 -->
    <textarea v-model="text"></textarea>
    
    <!-- 复选框 -->
    <input type="checkbox" v-model="checked" />
    
    <!-- 多个复选框 -->
    <input type="checkbox" value="Jack" v-model="checkedNames" />
    <input type="checkbox" value="John" v-model="checkedNames" />
    
    <!-- 单选按钮 -->
    <input type="radio" value="One" v-model="picked" />
    <input type="radio" value="Two" v-model="picked" />
    
    <!-- 选择框 -->
    <select v-model="selected">
      <option>A</option>
      <option>B</option>
      <option>C</option>
    </select>
    
    <!-- 修饰符 -->
    <input v-model.lazy="message" />  <!-- 在 change 时更新 -->
    <input v-model.number="age" />    <!-- 转为数字 -->
    <input v-model.trim="message" />  <!-- 去除首尾空格 -->
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: '',
      text: '',
      checked: false,
      checkedNames: [],
      picked: '',
      selected: '',
      age: 0
    }
  }
}
</script>
```

## 组件通信

### 父子组件通信

```vue
<!-- ParentComponent.vue -->
<template>
  <div>
    <!-- Props down -->
    <ChildComponent 
      :message="parentMessage"
      @child-event="handleChildEvent"
    />
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue'

export default {
  components: {
    ChildComponent
  },
  
  data() {
    return {
      parentMessage: 'Hello from parent'
    }
  },
  
  methods: {
    handleChildEvent(data) {
      console.log('Received from child:', data)
    }
  }
}
</script>

<!-- ChildComponent.vue -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="sendToParent">发送给父组件</button>
  </div>
</template>

<script>
export default {
  props: {
    message: {
      type: String,
      required: true
    }
  },
  
  methods: {
    sendToParent() {
      // Events up
      this.$emit('child-event', { data: 'Hello from child' })
    }
  }
}
</script>
```

### Event Bus（兄弟组件通信）

```javascript
// event-bus.js
import Vue from 'vue'
export const EventBus = new Vue()

// ComponentA.vue
import { EventBus } from './event-bus.js'

export default {
  methods: {
    sendMessage() {
      EventBus.$emit('message-sent', 'Hello from A')
    }
  }
}

// ComponentB.vue
import { EventBus } from './event-bus.js'

export default {
  created() {
    EventBus.$on('message-sent', (message) => {
      console.log('Received:', message)
    })
  },
  
  beforeDestroy() {
    EventBus.$off('message-sent')
  }
}
```

## Vuex 状态管理

```javascript
// store/index.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 0,
    todos: [],
    user: null
  },
  
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    },
    
    doneTodosCount: (state, getters) => {
      return getters.doneTodos.length
    },
    
    getTodoById: (state) => (id) => {
      return state.todos.find(todo => todo.id === id)
    }
  },
  
  mutations: {
    INCREMENT(state) {
      state.count++
    },
    
    SET_USER(state, user) {
      state.user = user
    },
    
    ADD_TODO(state, todo) {
      state.todos.push(todo)
    }
  },
  
  actions: {
    increment({ commit }) {
      commit('INCREMENT')
    },
    
    async fetchUser({ commit }, userId) {
      const response = await fetch(`/api/users/${userId}`)
      const user = await response.json()
      commit('SET_USER', user)
    },
    
    addTodo({ commit }, todo) {
      commit('ADD_TODO', todo)
    }
  }
})
```

### 在组件中使用 Vuex

```vue
<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Done: {{ doneTodosCount }}</p>
    <button @click="increment">+</button>
  </div>
</template>

<script>
import { mapState, mapGetters, mapMutations, mapActions } from 'vuex'

export default {
  computed: {
    // 使用对象展开运算符
    ...mapState(['count', 'todos']),
    
    // 使用对象形式
    ...mapState({
      userInfo: 'user'
    }),
    
    // 使用 getters
    ...mapGetters(['doneTodos', 'doneTodosCount'])
  },
  
  methods: {
    // 使用 mutations
    ...mapMutations(['INCREMENT']),
    
    // 使用 actions
    ...mapActions(['increment', 'fetchUser'])
  }
}
</script>
```

## Vue Router

```javascript
// router/index.js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '../views/Home.vue'

Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/about',
    name: 'About',
    // 懒加载
    component: () => import('../views/About.vue')
  },
  {
    path: '/user/:id',
    name: 'User',
    component: () => import('../views/User.vue'),
    props: true
  },
  {
    path: '/404',
    name: 'NotFound',
    component: () => import('../views/NotFound.vue')
  },
  {
    path: '*',
    redirect: '/404'
  }
]

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes
})

// 导航守卫
router.beforeEach((to, from, next) => {
  if (to.meta.requiresAuth && !isAuthenticated()) {
    next('/login')
  } else {
    next()
  }
})

export default router
```

### 在组件中使用路由

```vue
<template>
  <div>
    <!-- 声明式导航 -->
    <router-link to="/">Home</router-link>
    <router-link :to="{ name: 'User', params: { id: 123 }}">User</router-link>
    
    <!-- 路由出口 -->
    <router-view />
  </div>
</template>

<script>
export default {
  computed: {
    userId() {
      return this.$route.params.id
    }
  },
  
  methods: {
    // 编程式导航
    goToUser() {
      this.$router.push({ name: 'User', params: { id: 123 }})
    },
    
    goBack() {
      this.$router.go(-1)
    }
  },
  
  watch: {
    $route(to, from) {
      console.log('Route changed')
    }
  }
}
</script>
```

## Mixins

```javascript
// mixins/fetchData.js
export default {
  data() {
    return {
      isLoading: false,
      error: null
    }
  },
  
  methods: {
    async fetchData(url) {
      this.isLoading = true
      this.error = null
      
      try {
        const response = await fetch(url)
        return await response.json()
      } catch (error) {
        this.error = error.message
        throw error
      } finally {
        this.isLoading = false
      }
    }
  }
}

// 使用 mixin
import fetchDataMixin from '@/mixins/fetchData'

export default {
  mixins: [fetchDataMixin],
  
  async mounted() {
    const data = await this.fetchData('/api/users')
    console.log(data)
  }
}
```

## 指令

### 常用内置指令

```vue
<template>
  <div>
    <!-- v-if / v-else / v-else-if -->
    <p v-if="type === 'A'">A</p>
    <p v-else-if="type === 'B'">B</p>
    <p v-else>Not A/B</p>
    
    <!-- v-show -->
    <p v-show="isVisible">显示/隐藏</p>
    
    <!-- v-for -->
    <ul>
      <li v-for="item in items" :key="item.id">
        {{ item.text }}
      </li>
    </ul>
    
    <!-- v-bind -->
    <img :src="imageSrc" :alt="imageAlt" />
    
    <!-- v-on -->
    <button @click="handleClick">点击</button>
    
    <!-- v-model -->
    <input v-model="message" />
    
    <!-- v-html -->
    <div v-html="htmlContent"></div>
    
    <!-- v-text -->
    <span v-text="message"></span>
  </div>
</template>
```

### 自定义指令

```javascript
// 全局指令
Vue.directive('focus', {
  inserted: function (el) {
    el.focus()
  }
})

// 局部指令
export default {
  directives: {
    focus: {
      inserted(el) {
        el.focus()
      }
    },
    
    highlight: {
      bind(el, binding) {
        el.style.backgroundColor = binding.value
      },
      
      update(el, binding) {
        el.style.backgroundColor = binding.value
      }
    }
  }
}
```

## 性能优化

### 1. v-if vs v-show
```vue
<!-- 频繁切换使用 v-show -->
<div v-show="isVisible">Content</div>

<!-- 条件很少改变使用 v-if -->
<div v-if="isVisible">Content</div>
```

### 2. 使用 key
```vue
<div v-for="item in items" :key="item.id">
  {{ item.text }}
</div>
```

### 3. 计算属性缓存
```javascript
// ✅ 好 - 有缓存
computed: {
  fullName() {
    return this.firstName + ' ' + this.lastName
  }
}

// ❌ 差 - 每次都重新计算
methods: {
  getFullName() {
    return this.firstName + ' ' + this.lastName
  }
}
```

### 4. 事件监听清理
```javascript
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize)
  },
  
  beforeDestroy() {
    // 清理事件监听
    window.removeEventListener('resize', this.handleResize)
  }
}
```

### 5. 使用函数式组件
```vue
<template functional>
  <div class="cell">
    {{ props.value }}
  </div>
</template>

<script>
export default {
  name: 'Cell',
  functional: true,
  props: {
    value: String
  }
}
</script>
```

## 代码审查清单

- [ ] 是否使用正确的 Options API 顺序
- [ ] Props 是否有正确的类型验证
- [ ] 是否在 beforeDestroy 中清理定时器和事件监听
- [ ] 是否使用 key 在 v-for 中
- [ ] 是否避免 v-if 和 v-for 在同一元素上使用
- [ ] 计算属性是否没有副作用
- [ ] 是否正确使用 this.$set 添加响应式属性
- [ ] 是否使用 .sync 修饰符进行双向绑定
- [ ] 事件名称是否使用 kebab-case
- [ ] 是否正确使用 Vuex 管理全局状态

遵循这些规则，可以编写出高质量的 Vue 2 应用程序。

