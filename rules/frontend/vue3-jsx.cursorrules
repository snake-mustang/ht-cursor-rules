---
description: "Vue 3 + JSX/TSX 开发最佳实践，使用 TypeScript 和 Composition API"
globs:
  - "src/**/*.vue"
  - "src/**/*.tsx"
  - "src/**/*.jsx"
alwaysApply: false
---

# Vue 3 JSX/TSX 开发规则

You are an expert in Vue 3, JSX/TSX, TypeScript, and modern frontend development.

## 核心原则

- Write concise, technical TypeScript code with accurate JSX/TSX examples
- Use Vue 3 Composition API with JSX/TSX syntax
- Prefer functional and declarative programming patterns
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Follow Vue 3 and JSX best practices for component development

## Vue 3 + JSX/TSX 最佳实践

- Use `<script setup>` with JSX render functions or defineComponent with render function
- Leverage Vue 3's Composition API (ref, reactive, computed, watch)
- Use proper TypeScript interfaces for props and emits
- Implement v-model and event handling in JSX syntax
- Use fragments (<></>) for multiple root elements

## 组件结构示例

```tsx
import { defineComponent, ref, computed } from "vue"
import type { PropType } from "vue"

interface User {
  id: string
  name: string
  email: string
}

export default defineComponent({
  name: "UserProfile",
  props: {
    user: {
      type: Object as PropType<User>,
      required: true
    },
    editable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update", "delete"],
  setup(props, { emit }) {
    const isEditing = ref(false)
    const localUser = ref({ ...props.user })

    const displayName = computed(() => 
      `${localUser.value.name} (${localUser.value.email})`
    )

    const handleSave = () => {
      emit("update", localUser.value)
      isEditing.value = false
    }

    const handleDelete = () => {
      emit("delete", props.user.id)
    }

    return () => (
      <div class="user-profile">
        {isEditing.value ? (
          <div class="edit-mode">
            <input
              vModel={localUser.value.name}
              placeholder="Name"
              class="input"
            />
            <input
              vModel={localUser.value.email}
              placeholder="Email"
              class="input"
            />
            <button onClick={handleSave}>Save</button>
            <button onClick={() => isEditing.value = false}>Cancel</button>
          </div>
        ) : (
          <div class="view-mode">
            <h2>{displayName.value}</h2>
            {props.editable && (
              <>
                <button onClick={() => isEditing.value = true}>Edit</button>
                <button onClick={handleDelete}>Delete</button>
              </>
            )}
          </div>
        )}
      </div>
    )
  }
})
```

## JSX 语法规范

### 事件处理
- Event handling: `onClick`, `onInput`, `onChange`

### 属性绑定
- Props binding: `<Component propName={value} />`
- Class binding: `class={["base", { active: isActive.value }]}`
- Style binding: `style={{ color: textColor.value, fontSize: "14px" }}`

### 条件与列表渲染
- Conditional rendering: `{condition && <Component />}` or ternary
- List rendering: `{items.value.map(item => <Item key={item.id} data={item} />)}`

## Setup 函数与 JSX

```tsx
import { defineComponent, ref, onMounted } from "vue"

export default defineComponent({
  name: "Counter",
  setup() {
    const count = ref(0)
    const increment = () => count.value++
    const decrement = () => count.value--

    onMounted(() => {
      console.log("Component mounted")
    })

    return () => (
      <div class="counter">
        <button onClick={decrement}>-</button>
        <span class="count">{count.value}</span>
        <button onClick={increment}>+</button>
      </div>
    )
  }
})
```

## Slots 使用

```tsx
import { defineComponent } from "vue"

export default defineComponent({
  name: "Card",
  setup(props, { slots }) {
    return () => (
      <div class="card">
        <div class="card-header">
          {slots.header?.()}
        </div>
        <div class="card-body">
          {slots.default?.()}
        </div>
        <div class="card-footer">
          {slots.footer?.()}
        </div>
      </div>
    )
  }
})
```

## V-Model 实现

```tsx
import { defineComponent, ref } from "vue"

export const CustomInput = defineComponent({
  name: "CustomInput",
  props: {
    modelValue: String
  },
  emits: ["update:modelValue"],
  setup(props, { emit }) {
    const handleInput = (e: Event) => {
      const target = e.target as HTMLInputElement
      emit("update:modelValue", target.value)
    }

    return () => (
      <input
        value={props.modelValue}
        onInput={handleInput}
        class="custom-input"
      />
    )
  }
})

// 使用方式
const text = ref("")
<CustomInput vModel={text.value} />
```

## TypeScript 集成

```tsx
import { defineComponent, ref, PropType } from "vue"

interface Product {
  id: string
  name: string
  price: number
  inStock: boolean
}

export default defineComponent({
  name: "ProductCard",
  props: {
    product: {
      type: Object as PropType<Product>,
      required: true
    }
  },
  emits: {
    addToCart: (productId: string) => typeof productId === "string",
    viewDetails: (product: Product) => !!product.id
  },
  setup(props, { emit }) {
    const quantity = ref(1)

    const handleAddToCart = () => {
      if (props.product.inStock) {
        emit("addToCart", props.product.id)
      }
    }

    return () => (
      <div class="product-card">
        <h3>{props.product.name}</h3>
        <p class="price">${props.product.price}</p>
        <div class="stock-status">
          {props.product.inStock ? (
            <span class="in-stock">In Stock</span>
          ) : (
            <span class="out-of-stock">Out of Stock</span>
          )}
        </div>
        <input
          type="number"
          vModel={quantity.value}
          min="1"
          disabled={!props.product.inStock}
        />
        <button
          onClick={handleAddToCart}
          disabled={!props.product.inStock}
        >
          Add to Cart
        </button>
      </div>
    )
  }
})
```

## 最佳实践

- Use TypeScript for type safety
- Keep JSX components pure and focused
- Extract complex logic into composables
- Use proper key attributes for list rendering
- Implement proper error boundaries
- Optimize re-renders with computed and memo patterns
- Use async components for code splitting
- Follow Vue 3 Composition API patterns

## 测试

- Use Vitest or Jest for unit testing
- Test components with Vue Test Utils
- Mock composables and external dependencies
- Test user interactions and edge cases

## 依赖

- Vue 3.x
- TypeScript 5.x
- Vite (recommended)
- @vitejs/plugin-vue-jsx
- Vue Test Utils (for testing)

参考 Vue 3 和 JSX/TSX 官方文档以获取详细指导。
