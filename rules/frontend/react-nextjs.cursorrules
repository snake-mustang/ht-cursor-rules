---
description: "React + Next.js 全栈开发规范"
globs:
  - "src/**/*.tsx"
  - "app/**/*"
  - "pages/**/*"
alwaysApply: false
---

# React + Next.js 开发规则

你是 React 和 Next.js 开发专家，精通 React 18+ 和 Next.js 13+ App Router，编写高性能、符合最佳实践的现代 Web 应用。

## 核心原则

### 1. 项目结构
```
app/
├── layout.tsx          # 根布局
├── page.tsx            # 首页
├── loading.tsx         # 加载状态
├── error.tsx           # 错误处理
├── not-found.tsx       # 404 页面
├── api/                # API 路由
│   └── users/
│       └── route.ts
└── (routes)/           # 路由组
    ├── dashboard/
    │   ├── layout.tsx
    │   └── page.tsx
    └── blog/
        ├── [slug]/
        │   └── page.tsx
        └── page.tsx

components/
├── ui/                 # UI 组件
├── forms/              # 表单组件
└── layouts/            # 布局组件

lib/
├── utils.ts            # 工具函数
├── api.ts              # API 客户端
└── hooks/              # 自定义 Hooks
```

### 2. 命名规范
- **组件文件**：PascalCase（如 `UserProfile.tsx`, `Button.tsx`）
- **工具文件**：camelCase（如 `formatDate.ts`, `apiClient.ts`）
- **组件名称**：PascalCase（如 `const UserProfile = () => {}`）
- **Hook 名称**：use 前缀 + camelCase（如 `useUser`, `useDebounce`）

## React 组件最佳实践

### 函数组件和 Hooks

```typescript
'use client'

import { useState, useEffect, useCallback, useMemo } from 'react'

interface UserProfileProps {
  userId: string
  onUpdate?: (user: User) => void
}

interface User {
  id: string
  name: string
  email: string
}

export default function UserProfile({ userId, onUpdate }: UserProfileProps) {
  // ✅ 状态管理
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // ✅ useCallback - 记忆化回调函数
  const fetchUser = useCallback(async (id: string) => {
    setIsLoading(true)
    setError(null)
    
    try {
      const response = await fetch(`/api/users/${id}`)
      if (!response.ok) throw new Error('Failed to fetch')
      const data = await response.json()
      setUser(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error')
    } finally {
      setIsLoading(false)
    }
  }, [])

  // ✅ useEffect - 副作用处理
  useEffect(() => {
    fetchUser(userId)
  }, [userId, fetchUser])

  // ✅ useMemo - 记忆化计算值
  const displayName = useMemo(() => {
    return user ? user.name.toUpperCase() : ''
  }, [user])

  // ✅ 事件处理
  const handleUpdate = useCallback(() => {
    if (user && onUpdate) {
      onUpdate(user)
    }
  }, [user, onUpdate])

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error}</div>
  if (!user) return null

  return (
    <div className="user-profile">
      <h2>{displayName}</h2>
      <p>{user.email}</p>
      <button onClick={handleUpdate}>Update</button>
    </div>
  )
}
```

## Next.js App Router

### 服务端组件（默认）

```typescript
// app/users/page.tsx
// 这是一个服务端组件（默认）

interface User {
  id: string
  name: string
}

async function getUsers(): Promise<User[]> {
  const res = await fetch('https://api.example.com/users', {
    // ✅ 重新验证缓存
    next: { revalidate: 3600 } // 每小时重新验证
  })
  
  if (!res.ok) throw new Error('Failed to fetch users')
  return res.json()
}

export default async function UsersPage() {
  // ✅ 直接在组件中获取数据
  const users = await getUsers()

  return (
    <div>
      <h1>Users</h1>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  )
}

// ✅ 生成元数据
export async function generateMetadata() {
  return {
    title: 'Users - My App',
    description: 'List of all users'
  }
}
```

### 客户端组件

```typescript
// components/Counter.tsx
'use client' // ✅ 标记为客户端组件

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  )
}
```

### 动态路由

```typescript
// app/blog/[slug]/page.tsx

interface PageProps {
  params: { slug: string }
  searchParams: { [key: string]: string | string[] | undefined }
}

export default async function BlogPost({ params }: PageProps) {
  const post = await getPost(params.slug)

  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  )
}

// ✅ 生成静态参数
export async function generateStaticParams() {
  const posts = await getPosts()
  
  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

### 布局组件

```typescript
// app/dashboard/layout.tsx

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="dashboard-layout">
      <aside className="sidebar">
        <nav>{/* 导航菜单 */}</nav>
      </aside>
      <main className="main-content">
        {children}
      </main>
    </div>
  )
}
```

### 加载状态

```typescript
// app/dashboard/loading.tsx

export default function Loading() {
  return (
    <div className="loading">
      <div className="spinner" />
      <p>Loading...</p>
    </div>
  )
}
```

### 错误处理

```typescript
// app/dashboard/error.tsx
'use client'

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

## API 路由

```typescript
// app/api/users/route.ts

import { NextRequest, NextResponse } from 'next/server'

// GET 请求
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const query = searchParams.get('query')

  const users = await getUsers(query)

  return NextResponse.json({ users })
}

// POST 请求
export async function POST(request: NextRequest) {
  const body = await request.json()

  const user = await createUser(body)

  return NextResponse.json({ user }, { status: 201 })
}

// PUT 请求
export async function PUT(request: NextRequest) {
  const body = await request.json()
  const user = await updateUser(body)

  return NextResponse.json({ user })
}

// DELETE 请求
export async function DELETE(request: NextRequest) {
  const id = request.nextUrl.searchParams.get('id')
  await deleteUser(id!)

  return NextResponse.json({ success: true })
}
```

### 动态 API 路由

```typescript
// app/api/users/[id]/route.ts

interface RouteContext {
  params: { id: string }
}

export async function GET(
  request: NextRequest,
  { params }: RouteContext
) {
  const user = await getUserById(params.id)

  if (!user) {
    return NextResponse.json(
      { error: 'User not found' },
      { status: 404 }
    )
  }

  return NextResponse.json({ user })
}
```

## 数据获取

### 并行数据获取

```typescript
async function Page() {
  // ✅ 并行获取
  const [users, posts] = await Promise.all([
    getUsers(),
    getPosts()
  ])

  return (
    <div>
      <Users data={users} />
      <Posts data={posts} />
    </div>
  )
}
```

### 串行数据获取

```typescript
async function Page() {
  // ✅ 等待第一个请求
  const user = await getUser()
  
  // ✅ 使用第一个请求的结果
  const posts = await getUserPosts(user.id)

  return (
    <div>
      <User data={user} />
      <Posts data={posts} />
    </div>
  )
}
```

### 重新验证数据

```typescript
// 时间间隔重新验证
fetch('https://...', { next: { revalidate: 3600 } })

// 按需重新验证
import { revalidatePath, revalidateTag } from 'next/cache'

// 重新验证路径
revalidatePath('/blog')

// 重新验证标签
fetch('https://...', { next: { tags: ['posts'] } })
revalidateTag('posts')
```

## Server Actions

```typescript
// app/actions.ts
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost(formData: FormData) {
  const title = formData.get('title') as string
  const content = formData.get('content') as string

  await db.post.create({
    data: { title, content }
  })

  revalidatePath('/blog')
}

// app/blog/new/page.tsx
import { createPost } from '../actions'

export default function NewPost() {
  return (
    <form action={createPost}>
      <input name="title" />
      <textarea name="content" />
      <button type="submit">Create Post</button>
    </form>
  )
}
```

## 自定义 Hooks

```typescript
// lib/hooks/useDebounce.ts

import { useEffect, useState } from 'react'

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}

// 使用
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('')
  const debouncedSearch = useDebounce(searchTerm, 500)

  useEffect(() => {
    // 使用 debouncedSearch 进行搜索
  }, [debouncedSearch])

  return <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
}
```

## 中间件

```typescript
// middleware.ts

import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  // 检查认证
  const token = request.cookies.get('token')

  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/dashboard/:path*',
}
```

## 图片优化

```typescript
import Image from 'next/image'

export default function Avatar() {
  return (
    <Image
      src="/avatar.jpg"
      alt="Avatar"
      width={100}
      height={100}
      // ✅ 优先加载
      priority
      // ✅ 占位符
      placeholder="blur"
      blurDataURL="data:image/..."
      // ✅ 样式
      className="rounded-full"
    />
  )
}
```

## 字体优化

```typescript
// app/layout.tsx

import { Inter, Roboto_Mono } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})

const robotoMono = Roboto_Mono({
  subsets: ['latin'],
  display: 'swap',
})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  )
}
```

## 环境变量

```typescript
// .env.local
DATABASE_URL=postgresql://...
NEXT_PUBLIC_API_URL=https://api.example.com

// 使用
const dbUrl = process.env.DATABASE_URL // 服务端
const apiUrl = process.env.NEXT_PUBLIC_API_URL // 客户端和服务端
```

## 性能优化

### 1. 动态导入

```typescript
import dynamic from 'next/dynamic'

// ✅ 懒加载组件
const DynamicComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <p>Loading...</p>,
  ssr: false // 禁用服务端渲染
})
```

### 2. React.memo

```typescript
import { memo } from 'react'

const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // 只在 props 变化时重新渲染
  return <div>{data}</div>
})
```

### 3. useCallback 和 useMemo

```typescript
function Component() {
  // ✅ 记忆化回调
  const handleClick = useCallback(() => {
    console.log('clicked')
  }, [])

  // ✅ 记忆化计算
  const expensiveValue = useMemo(() => {
    return computeExpensiveValue(data)
  }, [data])
}
```

## TypeScript 最佳实践

```typescript
// ✅ Props 类型定义
interface ButtonProps {
  children: React.ReactNode
  onClick?: () => void
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

// ✅ 泛型组件
function List<T>({ items, renderItem }: {
  items: T[]
  renderItem: (item: T) => React.ReactNode
}) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  )
}

// ✅ 事件处理类型
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value)
}

const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault()
}
```

## 代码审查清单

- [ ] 是否使用 TypeScript 类型安全
- [ ] 服务端组件是否标记为 async
- [ ] 客户端组件是否有 'use client' 指令
- [ ] 是否使用 useCallback/useMemo 优化性能
- [ ] API 路由是否有错误处理
- [ ] 是否使用 Next.js Image 组件优化图片
- [ ] 动态路由是否实现 generateStaticParams
- [ ] 是否正确使用数据重新验证
- [ ] 环境变量是否正确配置
- [ ] 是否实现 loading 和 error 状态

遵循这些规则，可以编写出高性能的 React + Next.js 应用。

